\documentclass[11pt,a4paper]{article}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[expansion=false]{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[backend=biber,style=numeric,sorting=nyt]{biblatex}
\addbibresource{refs.bib}
\usepackage{listings}


% Define custom colors
\definecolor{soliditybg}{HTML}{F9F9F9}
\definecolor{soliditykeyword}{HTML}{005CC5}
\definecolor{soliditystring}{HTML}{032F62}
\definecolor{soliditycomment}{HTML}{6A737D}
\definecolor{soliditytype}{HTML}{22863A}
\definecolor{soliditynumber}{HTML}{B31D28}

% Solidity language definition
\lstdefinelanguage{Solidity}{
    keywords={
        pragma, solidity, contract, library, interface, is, struct, enum,
        function, modifier, event, constructor, fallback, receive, returns,
        if, else, for, while, do, continue, break, return, emit, revert,
        require, assert, mapping, storage, memory, calldata, public, private,
        internal, external, pure, view, payable, virtual, override, immutable,
        constant, delete, new, try, catch, assembly, return
    },
    keywordstyle=\color{soliditykeyword}\bfseries,
    ndkeywords={
        uint, uint8, uint16, uint32, uint64, uint128, uint256,
        int, int8, int16, int32, int64, int128, int256,
        address, bool, string, bytes, bytes1, bytes32, mapping, var
    },
    ndkeywordstyle=\color{soliditytype}\bfseries,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{soliditycomment}\ttfamily,
    stringstyle=\color{soliditystring},
    morestring=[b]',
    morestring=[b]",
    sensitive=true
}

% Solidity style
\lstdefinestyle{solidity}{
    language=Solidity,
    backgroundcolor=\color{soliditybg},
    basicstyle=\ttfamily\small,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    tabsize=2,
    showspaces=false,
    showstringspaces=false,
    breaklines=true,
    breakatwhitespace=true,
    captionpos=b,
    frame=single,
    rulecolor=\color{gray!40},
    frameround=tttt,
    keywordstyle=\color{soliditykeyword}\bfseries,
    ndkeywordstyle=\color{soliditytype}\bfseries,
    commentstyle=\color{soliditycomment}\itshape,
    stringstyle=\color{soliditystring},
}


\title{Report: Decentralized Inheritance Protocol}
\author{Noah Klaholz, Vincent Schall, Max Mendes Carvalho }
\date{November 2025}

\usepackage[toc,page]{appendix}
\usepackage{sectsty}
\allsectionsfont{\sffamily}

\begin{document}

    \maketitle
    \tableofcontents
    \clearpage

    \section{Introduction}\label{sec:introduction}
    \subsection{Motivation}\label{subsec:motivation}
    No one can escape death - but what happens to your crypto when you die?
    According to~\parencite{Bidget2025}, it is estimated that around 3.7 million Bitcoin are lost and unrecoverable.
    One of the top reasons is death: crypto holders that passed away and failed to share access information with heirs will be responsible for inaccessible funds.\newline
    Traditional inheritance systems are flawed: they take very long, are expensive and more often than not lead to conflict between the heirs.
    We want to solve these problems by introducing a decentralized inheritance protocol.\newline


    \subsection{The Decentralized Inheritance Protocol}\label{subsec:decentralized-inheritance-protocol}

    The idea is as follows: anyone can create a will by deploying the inheritance protocol contract.
    After that, depositing coins, tokens and assets, as well as defining beneficiaries or heirs by adding their wallet addresses, is quick and easy with function calls to the contract.
    For each beneficiary, the owner can define a payout amount as a percentage of the total deposited assets.\newline
    Furthermore, deposited assets are invested using Aave\footnotemark.
    This allows the balance to grow instead of laying dry.\newline
    The owner has to check in at least every 90 days to verify that he's still alive.
    As long as these check-ins occur, there will be no payout.
    When a check in is missed there is a 30-day grace period during which a check in can be made again \textcolor{red}{TODO}

    In case of death, trusted oracles (in most cases a notary) are used to verify the death via death certificates, before initiating the payout.
    \footnotetext{Aave — a decentralized lending protocol: supply crypto to earn interest via liquidity pools. \url{https://aave.com/docs/developers/liquidity-pool}}

    \section{Smart Contract architecture}\label{sec:smart-contract-architecture}

    \section{Decisions} //TODO rename this, but should be about why we did certain things, why abandon vesting for example etc.

    \section{Tool usage / tech stack}

    \section{Appendix}\label{sec:appendix}

    \begin{appendices}

        \begin{lstlisting}[style=solidity,caption={smart contract},label={lst:inheritance-protocol-code}]

        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.28;

        import "@openzeppelin/contracts/access/Ownable.sol";
        import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
        import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
        import {IDeathOracle} from "./mocks/IDeathOracle.sol";
        import {MockAavePool} from "./mocks/MockAavePool.sol";

        contract InheritanceProtocol is Ownable, ReentrancyGuard {

            IERC20 public immutable usdc;
            IDeathOracle public immutable deathOracle;
            address private notaryAddress;
            MockAavePool public aavePool;

            // address for donations (underdetermined payout)
            address private ourAddress;

            /**
             * Stores address and payout percentage amount (0-100) of a beneficiary.
             */
            struct Beneficiary {
                address payoutAddress;
                uint256 amount;
            }

            Beneficiary[10] private _beneficiaries;

            State private _currentState;

            uint256 private _lastCheckIn;
            bool private _called = false;

            uint256 private constant NOT_FOUND = type(uint256).max;
            uint256 private constant MAX_BENEFICIARIES = 10;
            uint256 private constant MAX_PERCENTAGE = 100;
            uint256 private constant CHECK_IN_PERIOD = 90 * 1 days;
            uint256 private constant GRACE_PERIOD = 30 * 1 days;

            event BeneficiaryAdded(address indexed payoutAddress, uint256 amount, uint256 index);
            event BeneficiaryRemoved(address indexed payoutAddress, uint256 index);
            event Deposited(uint256 amount);
            event Withdrawn(uint256 amount);
            event CheckedIn(uint256 timestamp);
            event StateChanged(uint256 timestamp, State from, State to);
            event PayoutMade(uint256 amount, address payoutAddress);
            event TestEvent(string s);
            event TestEventNum(uint s);

            /**
             * Initializes a new InheritanceProtocol.
             * @param _usdcAddress address of the currency used (non-zero).
             */
            constructor(address _usdcAddress, address _deathOracleAddress, address _notaryAddress, address _aavePoolAddress) Ownable(msg.sender) {
                require(_usdcAddress != address(0), "USDC address zero");
                require(_deathOracleAddress != address(0), "Death Oracle address zero");
                ourAddress = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;
                usdc = IERC20(_usdcAddress);
                deathOracle = IDeathOracle(_deathOracleAddress);
                notaryAddress = _notaryAddress;
                aavePool = MockAavePool(_aavePoolAddress);
                _currentState = State.ACTIVE;
                _lastCheckIn = block.timestamp;
            }

            /// ---------- MODIFIERS ----------

            /**
             * This modifier requires the function call to be made before distribution.
             */
            modifier onlyPreDistribution() {
                require(_currentState < State.DISTRIBUTION, "Cannot modify funds post-distribution");
                _;
            }

            /**
             * This modifier requires the function call to be made in the ACTIVE or WARNING phase
             */
            modifier onlyActiveWarning() {
                require(_currentState < State.VERIFICATION, "Cannot make administrative changes without Owner check-In");
                _;
            }

            /**
             * This modifier requires the function call to be made in the DISTRIBUTION phase
             */
            modifier onlyDistribution() {
                require(_currentState == State.DISTRIBUTION, "Can only make payouts in distribution phase");
                _;
            }

            /**
             * This modifier requires the function call to be made by the notary
             */
            modifier onlyNotary() {
                require(msg.sender == notaryAddress, "Only notary can call this function");
                _;
            }

            /// ---------- STATE MACHINE & CHECK-INS ----------

            /**
             * Defines the state of the contract.
             *  - Active: mutable state, owner check-ins required.
             *  - Warning: Missed check-in, notification sent at 90 days,
             *    verification phase starts at 120 days.
             *  - Verification: submission of death certificate (30 days).
             *  - Distribution: distribute assets based on defined conditions.
             */
            enum State { ACTIVE, WARNING, VERIFICATION, DISTRIBUTION }

            /**
             * Updates the State in the State-Machine
             * Should always be possible and accessible by anyone
             * @return currentState after execution
             */
            function updateState() public returns (State) {
                uint256 elapsed = uint256(block.timestamp) - _lastCheckIn;
                State oldState = _currentState;

                // --- Phase transitions in logical order ---

                // If in ACTIVE and check-in expired → WARNING
                if (_currentState == State.ACTIVE && elapsed > CHECK_IN_PERIOD) {
                    _currentState = State.WARNING;
                }

                // If in WARNING and grace period expired → VERIFICATION
                if (_currentState == State.WARNING && elapsed > CHECK_IN_PERIOD + GRACE_PERIOD) {
                    _currentState = State.VERIFICATION;
                }

                // If in VERIFICATION and death confirmed → DISTRIBUTION
                if (_currentState == State.VERIFICATION && deathOracle.isDeceased(owner())) {
                    _currentState = State.DISTRIBUTION;
                }

                emit StateChanged(block.timestamp, oldState, _currentState);

                // Trigger payout if we reached DISTRIBUTION
                if (_currentState == State.DISTRIBUTION) {
                    distributePayout();
                }

                return _currentState;
            }

            /**
             * Changes the state of the contract to a given state.
             * @param to the state to change to.
             */
            function changeState (State to) public {
                require(to != _currentState, "Already in requested state");
                emit StateChanged(block.timestamp, _currentState, to);
                _currentState = to;
            }

            /**
             * The owner checks in to verify that he's alive.
             * Should be possible in active and warning state.
             */
            function checkIn() public onlyOwner {
                require(_currentState == State.ACTIVE || _currentState == State.WARNING, "Need to be in active or warning state");
                emit CheckedIn(block.timestamp);
                _lastCheckIn = block.timestamp;
            }

            /// ---------- BENEFICIARY HANDLING ----------

            /**
             * Finds the index of a beneficiary in the beneficiaries list.
             * @param _address the address whose index to find.
             * @return the index if the address is in the list, 'NOT_FOUND' otherwise.
             */
            function findBeneficiaryIndex(address _address) public view returns (uint256) {
                if (_address == address(0)) {
                    return NOT_FOUND;
                }
                for (uint256 i = 0; i < MAX_BENEFICIARIES; i++) {
                    if (_beneficiaries[i].payoutAddress == _address) {
                        return i;
                    }
                }
                return NOT_FOUND;
            }

            /**
             * Removes a beneficiary with a given address.
             * Only the owner can perform this action.
             * @param _address the address to remove.
             * Fails if the provided address is zero OR not in the list of beneficiaries.
             * @return true if the deletion was successful, false otherwise.
             */
            function removeBeneficiary(address _address) public onlyOwner onlyActiveWarning returns (bool) {
                checkIn();
                uint256 index = findBeneficiaryIndex(_address);
                if (index == NOT_FOUND) {
                    return false;
                }
                delete _beneficiaries[index];
                emit BeneficiaryRemoved(_address, index);
                return true;
            }

            /**
             * Adds a beneficiary to the list.
             * Only the owner can perform this action.
             * Requirements:
             *  - List not full
             *  - Payout after adding <= 100
             * @param _address the address to add to the list.
             * @param _amount the payout amount related to this address.
             * @return true if the addition was successful, false otherwise.
             */
            function addBeneficiary(address _address, uint256 _amount) public onlyOwner onlyActiveWarning returns (bool) {
                checkIn();
                require(_address != address(0), "Invalid address");
                require(_amount > 0 && _amount <= MAX_PERCENTAGE, "Invalid amount");

                // Check for duplicate
                if (findBeneficiaryIndex(_address) != NOT_FOUND) {
                    return false;
                }

                uint256 currentSum = getDeterminedPayoutPercentage();
                if (currentSum + _amount > MAX_PERCENTAGE) {
                    // it should not be possible to payout more than 100%
                    return false;
                }

                // Find empty slot
                uint256 emptyIndex = NOT_FOUND;
                for (uint256 i = 0; i < MAX_BENEFICIARIES; i++) {
                    if (_beneficiaries[i].payoutAddress == address(0)) {
                        emptyIndex = i;
                        break;
                    }
                }

                if (emptyIndex == NOT_FOUND) {
                    return false; // Max beneficiaries reached
                }

                _beneficiaries[emptyIndex] = Beneficiary({ payoutAddress: _address, amount: _amount });
                emit BeneficiaryAdded(_address, _amount, emptyIndex);
                return true;
            }

            /// ---------- BALANCE HANDLING ----------

            /**
             * Deposits a given amount of USDC.
             * @param _amount the amount to deposit.
             */
            function deposit(uint256 _amount) external onlyOwner nonReentrant onlyPreDistribution {
                checkIn();
                require(_amount > 0, "Amount has to be greater than zero.");

                usdc.transferFrom(msg.sender, address(this), _amount);

                usdc.approve(address(aavePool), _amount);

                aavePool.supply(address(usdc), _amount, address(this));

                emit Deposited(_amount);
            }

            /**
             * Withdraws a given amount of USDC.
             * @param _amount the amount to withdraw.
             */
            function withdraw(uint256 _amount) external onlyOwner nonReentrant onlyPreDistribution {
                checkIn();
                require(_amount > 0, "Amount has to be greater than zero.");
                require(getBalance() >= _amount, "Insufficient balance");

                aavePool.withdraw(address(usdc), _amount, address(this));

                usdc.transfer(msg.sender, _amount);
                emit Withdrawn(_amount);
            }

            /// ---------- DEATH CERTIFICATION ----------

            /**
             * Upload the death verification to the chain
             * Only callable by the notary
             */
            function uploadDeathVerification(bool _deceased, bytes calldata _proof) external onlyNotary{
                deathOracle.setDeathStatus(owner(), _deceased, _proof);
            }

            /**
             * Checks if the owner died by calling death certificate oracle.
             * @return true if the owner died, else otherwise.
             */
            function checkIfOwnerDied() public view returns (bool) {
                return deathOracle.isDeceased(owner());
            }

            /// ---------- DISTRIBUTION METHODS ----------

            /**
             * Distributes the payout based on definitions given by owner.
             * Is only called in the updateState() Function, after death verification
             */
            function distributePayout() public {
                require(!_called, "Payout can only be called once.");
                _called = true;
                bool donation = !isPayoutFullyDetermined();
                uint256 count = getActiveCount();
                Beneficiary[] memory activeBeneficiaries = getActiveBeneficiaries();
                uint256 balanceRemainingInPool = getBalance();
                uint256 originalBalance = aavePool.withdraw(address(usdc), balanceRemainingInPool, address(this));
                for (uint256 i=0; i<count; i++) {
                    Beneficiary memory beneficiary = activeBeneficiaries[i];
                    uint256 amount = beneficiary.amount;
                    address payoutAddress = beneficiary.payoutAddress;

                    uint actualAmount = (originalBalance * amount) / MAX_PERCENTAGE;

                    usdc.transfer( payoutAddress, actualAmount);
                    emit PayoutMade(actualAmount, payoutAddress);
                }
                if (donation) {
                    // If the payout is not fully determined, the rest of the balance will be sent to the developer team.
                    // For now this is hardcoded as the first address generated by hardhat when running a local node.
                    uint256 donatedAmount = aavePool.withdraw(address(usdc), getBalance(), address(this));
                    usdc.transfer(ourAddress, donatedAmount);
                    emit PayoutMade(donatedAmount, ourAddress);
                }
            }

            /// ---------- VIEW METHODS ----------

            /**
             * Checks if the currently defined payout is fully determined, meaning
             * 100% of the balance is being spent.
             * @return true if the full balance will be spent, false otherwise.
             */
            function isPayoutFullyDetermined() public view returns (bool) {
                uint256 sum = getDeterminedPayoutPercentage();
                return sum == MAX_PERCENTAGE;
            }

            /**
             * Calculates the percentage amount of currently determined payout.
             * @return a number between 0 and 100, equivalent to the combined relative payout.
             */
            function getDeterminedPayoutPercentage() public view returns (uint256) {
                uint256 sum;
                for (uint256 i = 0; i < MAX_BENEFICIARIES; i++) {
                    if (_beneficiaries[i].payoutAddress != address(0)) {
                        sum += _beneficiaries[i].amount;
                    }
                }
                return sum;
            }

            /**
             * Gets the current balance.
             * @return the balance of the combined deposited funds.
             */
            function getBalance() public view returns (uint256) {
                return aavePool.getBalance(address(this));
            }

            /**
             * Getter for the beneficiaries list.
             * @return the list of 10 beneficiaries (might contain empty slots).
             */
            function getBeneficiaries() public view returns (Beneficiary[10] memory) {
                return _beneficiaries;
            }

            /**
             * Counts the number of active beneficiaries.
             * @return the number of active beneficiaries.
             */
            function getActiveCount() public view returns (uint256) {
                uint256 count;
                for (uint256 i = 0; i < MAX_BENEFICIARIES; i++) {
                    if (_beneficiaries[i].payoutAddress != address(0)) {
                        count++;
                    }
                }
                return count;
            }

            /**
             * Gets only the active beneficiaries.
             * @return an array of beneficiaries.
             */
            function getActiveBeneficiaries() public view returns (Beneficiary[] memory) {
                uint256 activeCount = getActiveCount();
                Beneficiary[] memory active = new Beneficiary[](activeCount);
                uint256 count = 0;
                for (uint256 i = 0; i < MAX_BENEFICIARIES; i++) {
                    if (_beneficiaries[i].payoutAddress != address(0)) {
                        active[count] = _beneficiaries[i];
                        count++;
                    }
                }
                return active;
            }

            /**
             * Gets the current state of the contract.
             * @return the current state.
             */
            function getState() public view returns (State) {
                return _currentState;
            }

            /**
             * Gets the last check-in time.
             * @return the last check-in time.
             */
            function getLastCheckIn() public view returns (uint256) {
                return _lastCheckIn;
            }

        }



        \end{lstlisting}

        \section{References}\label{sec:references}
        \printbibliography

    \end{appendices}

\end{document}
